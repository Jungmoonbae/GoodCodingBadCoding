## Chapter11. 정밀한 프로그램을 만드는 좋은 코딩 습관  

### 컴퓨터는 생각보다 정밀하지 않다.  
▷ 컴퓨터 및 디지털 기계는 0과 1을 이용하여 연산한다.  
▷ 있음과 없음. 혹은 참과 거짓을 명확하게 구분 짓는다는 점에서 사람들은 흔히 디지털 기계는 정확할 것이라는 편견을 가진다.  
▷ 2진수와 10진수의 비교  

2진수값 | 10진수값  
------- | --------  
0       | 0         
0.1     | 0.5       
0.01    | 0.25      
0.001   | 0.125     
0.0001  | 0.0625    


▷ 디지털 장비로 10진수의 소수 이하 부분을 정확하게 나타낼 수 없다.  
   (ex : 10진수 0.1, 0.2, 0.3 는 2진수로 어떻게 나타낼 수 있나?)  
▷ 10진수의 소수 이하 부분을 ‘약속’으로 정해 놓는다면 표현은 가능하지만  
   약속에 의해 정확함을 보장하는 것과 기계적으로 정확한 결과값이 나오는 것은  
   전혀 다른 애기라고 볼 수 있다.  


### 정밀한 계산이 필요하다면 부동소수점 연산을 피하라.  
▷ 컴퓨터로는 무한소수를 표현할 수 없다. 따라서 부동소수점은 특성상 늘 오차를 포함하게 된다. (ex: 1/3을 소수로 표현하면 0.33333…………)  
▷ 정밀한 계산을 필요로 하는 상황이라면 부동소수점 연산보다는 정수를 사용하는 것이 바람직하다.  
▷ C언어에서 소수 이하의 정확도를 float형 자료는 6자리까지만, double형은 15자리 까지만 보장하면서 적당한 자리에서 반올림 처리 해버린다.  

```
#include <studio.h>
int main(void) {
    float num1;
    float num2;

    num1 = 1.0f/3.0f + 1.0f/3.0f;  /* 결과는 0.666666 */
    num2 = 2.0f/3.0f;  /* 결과는 0.666667 */

    printf(“1/3 + 1/3 = %f \n”, num1);
    printf(“2/3 = %f \n”, num2);

    rutrun 0;
}
```


### 정밀한 계산에는 float형보다 double형을 사용하라.  
▷ float형은 단정밀도 부동소수점 자료형, double형은 배정밀도 부동소수점 자료형으로 double형은 float에 비해 두배 더 큰 자료형이다.  
▷ 정밀한 계산이 필요한 경우에는 float보다는 double형을 사용하면 좋다.  
▷ double형이 float형보다 크기 때문에 일부 컴파일러에서는 float가 계산속도가 더 빠르기도 하다. 하지만 일반적으로 C언어에서 float형을 계산할 때는 일단 double형으로 변환하여 계산하는데, double형일 때는 변환하는 과정이 생략되므로 double형 연산이 float보다 더 빠르다. 대부분의 컴퓨터에서 두 가지 형태의 연산은 큰 속도 차이가 나지 않으므로 정밀도를 고려하여 double형을 쓰는 편이 좋다.  

### 정수형의 크기를 확인하라.  
▷ 정수형의 크기가 컴퓨터마다 다르게 정의되어 있다.  ex) 유닉스 계열 O/S : 4바이트 (32비트)  
ex)  PC용 O/S : 2바이트 (16비트), 4바이트(32비트)  
▷ 정수형 자료의 크기가 16비트일 경우 -32768 ~ 32767 범위의 숫자를 표현할 수 있다. 최대치 최소치를 넘어버릴 경우 프로그램은 데이터 오버플로우 상태에 빠지며 프로그램 동작이 멈춰버린다.  

```
int plus_over = 32767; /*문제를 일으키지 않음*/ 
plus_over = plus_over + 1; /*데이터 오버플로우 발생 */
```

```
int minus_over = -32768; /*문제를 일으키지 않음*/ 
minus_over = minus_over - 1; /*데이터 오버플로우 발생 */
```

▷ 정수형 크기는 이식성에도 영향을 미친다.  
   즉, 유닉스에서 작성한 코드는 정수가 4바이트므로 정수형 크기가  2바이트인 pc에서는 작동하지 않게 된다.  

```
int number = 70000; /* int형을 4바이트로 가정 */  
long int number = 70000; /* int형을 2바이트로 가정 */  
```

▷ 모든 자료형의 크기가 시스템에 따라서 달라질 수 있으므로  
   실질적으로는 모든 자료형의 크기를 확인해둬야 한다.  
▷ 자료형의 크기는 컴파일러 매뉴얼에 기록되어 있고,  
   `<limits.h>` 파일에도 기재되어 있다.  
   `sizeof` 연산자를 사용하여 확인할 수 도 있다.  

### 계산 단위를 반드시 명시하라.  
▷ 대부분의 계산 프로그램은 단위가 제대로 기록되어있지 않다.  
   따라서 실질적인 계산 문장에서 단위착오를 일으킬 가능성이 있다.  
▷ 계산 단위는 프로그램의 머리 주석과 본문 주석 모두 달아 놓으면 좋다.  
   또한 본문 주석을 달 때도 변수 선언 부분에도 계산 단위를 명시하고,  
   실제적인 계산이 이루어지는 부분에도 계산단위를 명시해주면 좋다.  

```
/* 
프로그램 파일 이름 : account.c
목 적 : 연간 결산 수지 집계
계산 단위 : 원 단위, 천원 단위, 백만원 단위
구체적인 계산 단위는 각 변수 옆의 주석으로 확인할 것 
*/
int main(void) {
    int num;  /*당일 총결산 수지 : 원 단위로 계산*/
    int sum; /*한 달간 총결산 수지 : 천원 단위로 계산 */
    int total; /*일 년간 총결산 수지 : 백만원 단위로 계산*/
…중략…  
    sum = sum + (num / 1000); /*num은 원단위, sum은 천원단위*/
    total = total + (sum / 1000); /*sum은 천원단위, total은 백만원 단위*/
}
```


### 나눗셈 연산에는 주의를 기울여라.  

```
int num;
…중략…
num = 15 / 10;  /* 소수인 0.5가 제거되고 1이 된다*/     
```

▷ 정수형 자료간의 연산에서는 소수 이하 값이 제거된다.  

```
#include <studio.h>
float result;
int main(void) {
    result = 1/3;
    printf("1/3의 결과는 %f입니다.\n", result);
    return 0 ;
}
```

▷ 대부분 결과가 0.333333 일 것이라고 예측할 것이나 결과는 0이 나온다.  
   1/3 나눗셈의 결과는 0.333333… 이다.  
   두 피연산자가 모두 정수형이므로 결과값을 정수형으로 만든다.  
   즉 소수점이하를 누락시키고 0만 남긴다. 최종결과는 정수 0이 된다.  
   Result가 실수형이므로 0이 0.0으로 변환되어 대입된다.  
▷ 따라서 계산문장을 다음처럼 바꾸어야 정확한 연산을 할 수 있다.  
   연산에 사용되는 피연산자의 자료형이 모두 부동소수점이라서  
   중간에 자료형 변환이 일어나지 않기 때문이다.  

```
result = 1.0 / 3.0;  
```

### 자료형의 변환이 이루어지지 않도록 하라  
▷ 캐스트 연산자(casting operator)를 사용하여 쉽게 자료형을 변환하여 사용할 수 있다.  

``` 
float fNum;
…중략…
fNum = (float) (12+3);     
int iNum;
…중략…
iNum = (int) (fNum/3.0);     
```

▷ 자료형 변환에는 언제나 위험이 따르기 때문에  
   (큰 자료형을 작은 자료형으로 변환하게 되면 일부 데이터가 유실된다.  
   `double`형을 `float`형으로 변환하거나 `long double`형을 `double`형으로 바꾸는 경우를 예로 들 수 있다)  
   정밀한 계산을 필요로 하는 프로그램에서는 자료형 변환이 이루어지지 않도록 주의해야 한다.  
▷ 특히 암시적인 형 변환이 이루어지지 않았는지 주의해야한다.  

``` 
double pi = 3.14159;
long int num;
long int r;
…중략…
num = pi * r * r;    
```

▷ 자료형이 명시되지 않은 상태에서는 컴파일러에 의해 자동으로 자료형 변환이 이루어진다.  
   위의 예시에서 파이는 소수점을 포함하고 있지만, 반지름인 r값은 정수형이며  
   최종 대입되는 변수인 num 또한 정수형으로 암시적인 형변환이 이루어짐을 알 수 있다.  
   코드가 길어지게 되면 이런 케이스를 알기가 어렵기 때문에  
   아래와 같이 변수 모두를 동일한 자료형으로 선언해주어야 한다.  

```
double pi = 3.14159;
double num;
double r;
…중략…
num = pi * r * r;    
```

▷ 암시적인 자료형 변환을 방지하는 다른 방법은 변수 이름 앞에 자료형을 명시하는 것이다. 이 경우 프로그래머가 바로 확인할 수 있다는 장점이 있다.

```
double dPi = 3.14159;
long int liNum;
long int liRad;
…중략…
linum = dPi * liRad * liRad;     
```

### 확실하게 문법을 익혀둬라  
▷ C언어 및 대개의 인공 언어들의 사소해 보이는 문법이  
   프로그램을 크게 좌우하는 경우가 많다.  
   알고리즘 및 앱 개발 시 문법은 그 뿌리가 되므로 문법에 먼저 정통해야 한다. 
▷ 아래 문장에 연산자가 있을까?  

```
int array[10][2];    
```

▷ `[]`는 우선순위가 가장 높은 연산자이다.  
   c언어 표준에 따르면 `[]`의 결합 방향은 왼쪽에서 오른쪽 방향으로 이어진다.  
   즉, `[10]`이라는 연산이 먼저 되고나서 `[2]`라는 연산이 실행된다.  

### 계산 결과가 선형으로 나오지 않을 수 있다는 점에 주목하라.  
▷ 코더로서, 프로그래머로서, 시스템 설계자로서 반드시 명심해야 할 점은  
   반복되는 컴퓨터 연산의 결과가 우리의 기대와 크게 달라질 수 있다는 점이다.  
▷ 컴퓨터는 우리가 흔히 기대하는 대로 연산결과를 내놓지 않기도 한다.  
   따라서 코딩 중 잠재된 미세한 수치의 차이가 반복 연산되는 경우가 있다면,  
   반드시 그 결과를 반복해서 검증해보는 것이 바람직하다. =>나비효과  


